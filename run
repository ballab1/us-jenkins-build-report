#!/usr/bin/env bash

source etc/utils.shlib

# If this script is sourced skip the rest and return
[ "$0" = "$BASH_SOURCE" ] && v=run || return 0;

# override maven output directory 'target' & gradle ouput directory 'build/libs'
PKG_DIR=deploy
set_revision
MAIN_NS=none

jdk_ops='-J-XX:+IgnoreUnrecognizedVMOptions -J--add-modules=java.xml.bind,java.xml.ws'

function run_clj() {
   repl=-J-Dclojure.server.repl="{:port ${REPL_PORT} :accept clojure.core.server/repl}"
   nrepl="-J-Dnrepl.port=${NREPL_PORT}"
   aliases=:dev:test
   if [ "$1" == "jar" ]; then
      if [ -f ${FQ_APP} ]; then
         java -jar ${FQ_APP}
      else
         ./run pkg $MAIN_NS
         ./run dev jar
      fi
   elif [ "$1" == "itest" ]; then
     # In a shell 'run dev jar' & in another shell 'run itest' to interactively test drive the jar with vim.
     clj $jdk_ops "$repl" $nrepl -R$aliases -C$aliases -i src/dev/clj/init-cider.clj -m $MAIN_NS-test
   elif [ "$1" == "repl" ]; then
     # will include $CP/user.clj automatically
     clj $jdk_ops "$repl" $nrepl -A$aliases -i src/dev/clj/init-cider.clj -r
   elif [ "$1" == "nrepl" ]; then
     # will include $CP/user.clj automatically. https://nrepl.readthedocs.io/en/latest/usage
     clj $jdk_ops "$repl" $nrepl -A$aliases -i src/dev/clj/init-cider.clj -m nrepl.cmdline --interactive --color
   elif [ "$1" == "rebl" ]; then
     # use clojure since clj uses rlwrap. rebel-readline does not include $CP/user.clj.
     # Use -i explicitly but be sure to use (ns user) in -i script. Cannot use clojure "slim" classifier.
     clojure $jdk_ops "$repl" $nrepl -A$aliases -i src/dev/clj/init-cider.clj -i src/dev/clj/user.clj -m rebel-readline.main
   elif [ "$1" == "depstar" ]; then
      clj -Scp ${FQ_DS_APP} -m $MAIN_NS
   elif [ "$1" == "capsule" ]; then
      java -jar ${FQ_CAPS_APP}
   elif [ "$1" == "1jar" ]; then
      java -jar ${FQ_1JAR_APP} -m $MAIN_NS
   else
     # will include $CP/user.clj automatically
     clj $jdk_ops "$repl" $nrepl -R$aliases -C$aliases -i src/dev/clj/init-cider.clj -m $MAIN_NS
   fi
}

if [ "$1" == "dev" ]; then
   jenv graal; java -version
   set_repl_ports
   set_kafka_cluster localhost # Unless $KAFKA_IP is set
   bin/validate-kafka-env
   # Debug interactively against a production configuration. Check config.edn.
   #export CONFIG_PROFILE=':prod'; export TIMBRE_LEVEL=':debug'
   export RUN_DEV_MODE=true
   run_clj $2
elif [ "$1" == "prod" ]; then
   set_kafka_cluster hop       # Unless $KAFKA_IP is set
   bin/validate-kafka-env
   export CONFIG_PROFILE=':prod'
   # Debug interactively against a production environment.
   #export RUN_DEV_MODE=true; export TIMBRE_LEVEL=':debug'
   run_clj $2
elif [ "$1" == "pkg" ]; then
   jenv graal; java -version
   # Remove dependencies on development jars
   touch deps.edn
   clojure -Sverbose -Spom $*
   [ -d $PKG_DIR ] || mkdir $PKG_DIR
   if [ "$2" == "mvn" ]; then
      # 'auto merge' mvn plugins into the generated pom.xml. Only add clojure-maven-plugin xml when not present in pom.xml
      grep -q '^[ \t]*<artifactId>clojure-maven-plugin</artifactId>' pom.xml || sed -i -e '/<sourceDirectory>src\/main\/clj<\/sourceDirectory>/r src/dev/mvn-plug-res.xml' pom.xml
      [ -f pom.xml ] && rm pom.xml-e
      mvn package
   elif [ "$2" == "depstar" ]; then
      FQ_APP=${FQ_DS_APP}
      clj -A:depstar -m hf.depstar.uberjar ${FQ_APP}
   elif [ "$2" == "capsule" ]; then
      FQ_APP=${FQ_CAPS_APP}
      clj -A:pack mach.pack.alpha.capsule -m $MAIN_NS --application-id $APP --application-version $REVISION \
         -M "Built-By: $USER" -M "Build-Timestamp: $(date)" -M "Build-Host: $(uname -vn)" \
         ${FQ_APP}
   elif [ "$2" == "1jar" ]; then
      FQ_APP=${FQ_1JAR_APP}
      clj -A:pack mach.pack.alpha.one-jar ${FQ_APP}
   elif [ "$2" == "gradle" ]; then
      # run gradle with the JDK selected by this script.
      gradle -Dorg.gradle.java.home=$JAVA_HOME shadowJar
   else
      bin/pkg $MAIN_NS
   fi
   gen_proj_pom
   tar -cf `sed s/.jar$/.tar/g <<<${FQ_APP}` bin run ${FQ_APP_NS}.pom ${FQ_APP}
elif [ "$1" == "docker" ]; then
   # Repository name must be lowercase.
   lc_app=$(echo ${APP} | tr '[:upper:]' '[:lower:]')
   if [ "$2" == "run" ]; then
      # Optionally publish uS ports with -p port:port/tcp
      DOCKER_PARMS="--env-file ${DOCKER_ENV_FILE} --name ${APP} ${lc_app}:${REVISION}"
      is_docker_env_file_set
      docker stop ${APP}
      docker rm ${APP}
      if [ "$3" == "debug" ]; then
         docker run -t -i --entrypoint /bin/sh $DOCKER_PARMS
      else
         docker run -d $DOCKER_PARMS
      fi
      ./run docker ls
      # after 'run docker run' completes, run 'docker attach some-id'. Use ^p^q to exit the container.
   elif [ "$2" == "ls" ]; then
      echo "Containers..."
      docker ps -a --filter name=${APP}
      echo ""
      echo "Images..."
      docker images | grep ${APP}
   elif [ "$2" == "clean" ]; then
      docker rm $(docker ps -aq --filter name=${APP})
      docker rmi $(docker images | grep ${APP} | awk "{print \$3}")
      ./run docker ls
   elif [ "$2" == "scrub" ]; then
      ./run docker clean
      docker rmi $(docker images | grep '<none>' | awk "{print \$3}")
      docker images
   elif [ "$2" == "build" ]; then
      ./run clean
      if [ -z ${3}  ]; then
         # Build a jar without tooling
         ./run pkg $MAIN_NS
      else
         # Build a jar with capsule, 1jar, depstar, mvn or gradle
         ./run pkg $3
      fi
      # ./run pkg above may change $REVISION, be sure to pick that up.
      get_revision
      docker build -t ${lc_app}:${REVISION} .
   else
      ./run usage
   fi
elif [ "$1" == "clean" ]; then
   rm -rf $(cat etc/generated-artifacts | sed -e ':a' -e 'N' -e '$!ba' -e 's/\n/ /g')
else
   echo "Usage:"
   echo "   run clean"
   echo "   [KAFKA_IP=ip] [nohup] run dev|prod [repl|nrepl|rebl|itest|jar|depstar|capsule|1jar] [&]"
   echo "   run pkg [mvn|gradle|depstar|capsule|1jar]"
   echo "   run docker build [mvn|gradle|depstar|capsule|1jar]|run [debug]|clean|ls|scrub"
fi
