# https://stackoverflow.com/questions/29011295/compile-clojure-source-into-class-aot-from-command-line-not-using-lein

# This "simple" compile and jar packaging approach will handle building jars
# when a git cloned library repo is present in deps.edn AND we want the jar
# to consist only of compiled code. Neither gradle nor maven can produce a
# jar in this scenario as neither can handle a git source based dependency
# in the classpath. A compiled library is required.
#
# Alternate approaches like capsule, OneJAR, and depstar don't provide complete
# byte code compilation and possibly require clojure/clj to be installed. The
# "simple" approach handles either build scenario and we get source code
# obfuscation through compilation. No other dependencies other than a JRE are
# required to run the resulting jar.
#
# A side benefit is that we can compile and package without the need to
# install gradle or maven.

source etc/utils.shlib
set_revision

# Get the project's classpath
cpath=$(clj -Spath)

# Get the project's namespaces
namespaces=()
for file in $(find src/main/clj -name \*.clj); do
   drop_front=${file##src/main/clj/}
   drop_extension=${drop_front%%.clj}
   namespaces+="${drop_extension//\//.} "
done

target_dir=.classes
rm -rf $target_dir
[ -d $target_dir ] || mkdir $target_dir

# Find all jar files on the classpath and decompress them along side the
# project's compiled classes. WARNING the last class decompressed overwrites
# a previous version upon collision. Reverse process the list to match what a
# classloader would see.
files=(${cpath//:/ })
cd $target_dir;

manifest_cp=()
for (( i=${#files[@]}-1;i>=0;i-- )); do
   file=${files[i]}
   if [ -f $file ]; then
      echo "Extracting: $file into $target_dir"
      manifest_cp+=" ${file##*/} \n"
      jar xf $file
   fi
done

cd ..
sorted_manifest_cp=$(printf "$manifest_cp" | sort)

# Remove any file in $target_dir coming from the decompressed jars that is also
# in src/resources as the latter will override these in the uber jar.
for file in $(ls src/resources); do
   find $target_dir -type f -name $file -exec rm {} \;
done

# Create a manifest file
manifest=.manifest
echo "Title: $(cat .app-name)" > $manifest
echo "SCM-Revision: $(cat .revision)" >> $manifest
echo "Built-By: $USER" >> $manifest
echo "Build-Timestamp: $(date)" >> $manifest
echo "Build-Host: $(uname -vn)" >> $manifest
echo "Built-With: $0" >> $manifest
#echo "Main-Class: msa.core" >> $manifest
echo "Class-Path: $sorted_manifest_cp" >> $manifest

# Compile the project's namespaces like msa.core. WARNING compiled project
# classes will overwrite decompressed jars classes upon collision.
java -cp $target_dir:$cpath -Dclojure.compile.path=$target_dir clojure.lang.Compile $namespaces

# Create the project's uberjar including project class files, resources and jar class files.
[ -d deploy ] || mkdir deploy
jar_name="deploy/$(cat .app-name)-$(cat .revision).jar"
echo "Creating $jar_name"
jar cmf $manifest $jar_name -C $target_dir . -C src/resources .
